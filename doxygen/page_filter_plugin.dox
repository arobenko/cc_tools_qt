/// @page page_filter_plugin Developing Custom Filter Plugin
/// @tableofcontents
/// The @b filter plugin is responsible to perform intermediate processing of
/// incoming data after it has been received by the I/O @b socket and prior to it
/// it being delivered to the @b protocol. It is also responsible to perform
/// intermediate processing of outgoing data generated by the @b protocol and 
/// prior to it being delivered to I/O @b socket for sending.
/// 
/// The @b filters can be used to implement additional transport layer, such
/// as <a href="http://mqtt.org">MQTT</a> or
/// <a href="http://mqtt.org/2013/12/mqtt-for-sensor-networks-mqtt-sn">MQTT-SN</a>.
/// They can also be used to implement enctyption / decryption of the outgoing /
/// incoming data.
///
/// @section page_filter_plugin_filter_class Filter Class
/// To implement the required functionality the plugin's code must define its
/// filter class inheriting from cc_tools_qt::Filter. 
/// @code
/// class MyFilter : public cc_tools_qt::Filter
/// {
///     ...
/// };
/// @endcode
/// If filter implementation uses Qt signals/slots infrastructure, it can use
/// multiple inheritance and extend @b QObject as well.
/// @code
/// class MyFilter : public QObject, public cc_tools_qt::Filter
/// {
///     Q_OBJECT
///     ...
/// private slots:
///     ...
/// };
/// @endcode
/// The cc_tools_qt::Filter class is implemented using  
/// <a href="https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Non-Virtual_Interface">Non-Virtual Interface Idiom</a>
/// It's non-virtual public interface is used by the driving application. The
/// inheriting class needs to implement virtual @b *Impl() functions to override
/// the default behaviour.
///
/// @subsection page_filter_plugin_start_stop Start / Stop
/// The @b filter object is not allowed to generate any events prior to being
/// explicity @b started. It is also not allowed to generate any events after
/// it has been exlicitly @b stopped. The driving application will use explicit
/// calls to cc_tools_qt::Filter::start() and cc_tools_qt::Filter::stop()
/// to control the operation of the filter. In order to receive the notifications
/// on the start / stop operations, the actual filter class needs to override
/// virtual cc_tools_qt::Filter::startImpl() and 
/// cc_tools_qt::Filter::stopImpl().
/// @code
/// class MyFilter : public cc_tools_qt::Filter
/// {
///     ...
/// protected:
///     virtual bool startImpl() override;
///     virtual void stopImpl() override;
/// };
/// @endcode
///
/// @subsection page_filter_plugin_socket_connect Socket Connection Status
/// The communication link is driven by the @ref page_socket_plugin "socket" plugin.
/// Quite often it can be necessary for the filter plugin to be aware about socket
/// connection status. To do so override the virtual @ref cc_tools_qt::Filter::socketConnectionReportImpl()
/// function
/// @code
/// class MyFilter : public cc_tools_qt::Filter
/// {
///     ...
/// protected:
///     virtual void socketConnectionReportImpl(bool connected) override;
/// };
/// @endcode
///
/// @subsection page_filter_plugin_data_proc Processing Data
/// The new incoming data will be reported to the @b filter using virtual
/// cc_tools_qt::Filter::recvDataImpl(). The derived class must override and
/// implement it.
/// @code
/// class MyFilter : public cc_tools_qt::Filter
/// {
///     ...
/// protected:
///     virtual QList<cc_tools_qt::ToolsDataInfoPtr> recvDataImpl(cc_tools_qt::ToolsDataInfoPtr dataPtr) override;
/// };
/// @endcode
/// @b NOTE, that the return value from the function is a list of smart pointers
/// to cc_tools_qt::ToolsDataInfo. Every such "data chunk" will be forwarded
/// separately to the @b protocol or other @b filter up the chain.
///
/// The @b filter is allowed to consume the provided data and not to report
/// anything for further processing. In this case the returned list will be empty.
///
/// The outgoing data generated by the @b protocol and/or other filter will be
/// reported using virtual cc_tools_qt::Filter::sendDataImpl(). The 
/// derived class must override and implement it.
/// @code
/// class MyFilter : public cc_tools_qt::Filter
/// {
///     ...
/// protected:
///     virtual QList<cc_tools_qt::ToolsDataInfoPtr> sendDataImpl(cc_tools_qt::ToolsDataInfoPtr dataPtr) override;
/// };
/// @endcode
/// It is very similar to @b recvDataImpl() mentioned above
///
/// @subsection page_filter_plugin_data_gen Generating Data
/// The @b filter class is allowed to generate outgoing data independently. It
/// could be required when implementing "additional transport layer" filtering.
/// If such data needs to be set, the @b filter class should use inherited
/// cc_tools_qt::Filter::reportDataToSend() protected member function.
///
/// @subsection page_filter_plugin_errors Reporting Errors
/// If there is any error discovered, the @b filter object is expected to report 
/// them using inherited cc_tools_qt::Filter::reportError() member function.
///
/// @section page_filter_plugin_plugin_class Plugin Class
/// Please read the @ref page_plugin page first to understand the way the 
/// plugins are defined.
///
/// The @b filter plugin must provide a callback to allocate the 
/// @b Filter object (the one that is derived from cc_tools_qt::Filter).
/// @code
/// class MyFilterPlugin : public cc_tools_qt::Plugin
/// {
///     Q_OBJECT
///     Q_PLUGIN_METADATA(IID "MyUniqueFilterId" FILE "my_filter.json")
///     Q_INTERFACES(cc_tools_qt::Plugin)
///
/// public:
///     MyFilterPlugin()
///     {
///         pluginProperties()
///             .setFiltersCreateFunc(
///                 [this]() -> cc_tools_qt::PluginProperties::ListOfFilters
///                 {
///                     cc_tools_qt::PluginProperties::ListOfFilters filters;
///                     filters.append(cc_tools_qt::ToolsFilterPtr(new MyFilter));
///                     return filters;
///                 });
///     }
///             
///     ...
/// };
/// @endcode
/// If the @b filter requires configuration, please also provide a callback which
/// creates the widget when invoked (see @ref page_plugin_properties_config_widget).

