/// @page page_filter_plugin Developing Custom Filter Plugin
/// @tableofcontents
/// The @b filter plugin is responsible to perform intermediate processing of
/// incoming data after it has been received by the I/O @b socket and prior to it
/// it being delivered to the @b protocol. It is also responsible to perform
/// intermediate processing of outgoing data generated by the @b protocol and 
/// prior to it being delivered to I/O @b socket for sending.
/// 
/// The @b filters can be used to implement additional transport layer, such
/// as <a href="http://mqtt.org">MQTT</a> or
/// <a href="http://mqtt.org/2013/12/mqtt-for-sensor-networks-mqtt-sn">MQTT-SN</a>.
/// They can also be used to implement enctyption / decryption of the outgoing /
/// incoming data.
///
/// @section page_filter_plugin_filter_class Filter Class
/// To implement the required functionality the plugin's code must define its
/// filter class inheriting from comms_champion::Filter. 
/// @code
/// class MyFilter : public comms_champion::Filter
/// {
///     ...
/// };
/// @endcode
/// If filter implementation uses QT5 signals/slots infrastructure, it can use
/// multiple inheritance and extend @b QObject as well.
/// @code
/// class MyFilter : public QObject, public comms_champion::Filter
/// {
///     Q_OBJECT
///     ...
/// private slots:
///     ...
/// };
/// @endcode
/// The comms_champion::Filter class is implemented using  
/// <a href="https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Non-Virtual_Interface">Non-Virtual Interface Idiom</a>
/// It's non-virtual public interface is used by the driving application. The
/// inheriting class needs to implement virtual @b *Impl() functions to override
/// the default behaviour.
///
/// @subsection page_filter_plugin_start_stop Start / Stop
/// The @b filter object is not allowed to generate any events prior to being
/// explicity @b started. It is also not allowed to generate any events after
/// it has been exlicitly @b stopped. The driving application will use explicit
/// calls to comms_champion::Filter::start() and comms_champion::Filter::stop()
/// to control the operation of the filter. In order to receive the notifications
/// on the start / stop operations, the actual filter class needs to override
/// virtual comms_champion::Filter::startImpl() and 
/// comms_champion::Filter::stopImpl().
/// @code
/// class MyFilter : public comms_champion::Filter
/// {
///     ...
/// protected:
///     virtual bool startImpl() override;
///     virtual void stopImpl() override;
/// };
/// @endcode
///
/// @subsection page_filter_plugin_data_proc Processing Data
/// The new incoming data will be reported to the @b filter using virtual
/// comms_champion::Filter::recvDataImpl(). The derived class must override and
/// implement it.
/// @code
/// class MyFilter : public comms_champion::Filter
/// {
///     ...
/// protected:
///     virtual QList<comms_champion::DataInfoPtr> recvDataImpl(comms_champion::DataInfoPtr dataPtr) override;
/// };
/// @endcode
/// @b NOTE, that the return value from the function is a list of smart pointers
/// to comms_champion::DataInfo. Every such "data chunk" will be forwarded
/// separately to the @b protocol or other @b filter up the chain.
///
/// The @b filter is allowed to consume the provided data and not to report
/// anything for further processing. In this case the returned list will be empty.
///
/// The outgoing data generated by the @b protocol and/or other filter will be
/// reported using virtual comms_champion::Filter::sendDataImpl(). The 
/// derived class must override and implement it.
/// @code
/// class MyFilter : public comms_champion::Filter
/// {
///     ...
/// protected:
///     virtual QList<comms_champion::DataInfoPtr> sendDataImpl(comms_champion::DataInfoPtr dataPtr) override;
/// };
/// @endcode
/// It is very similar to @b recvDataImpl() mentioned above
///
/// @subsection page_filter_plugin_data_gen Generating Data
/// The @b filter class is allowed to generate outgoing data independently. It
/// could be required when implementing "additional transport layer" filtering.
/// If such data needs to be set, the @b filter class should use inherited
/// comms_champion::Filter::reportDataToSend() protected member function.
///
/// @subsection page_filter_plugin_errors Reporting Errors
/// If there is any error discovered, the @b filter object is expected to report 
/// them using inherited comms_champion::Filter::reportError() member function.
///
/// @section page_filter_plugin_plugin_class Plugin Class
/// Please read the @ref page_plugin page first to understand the way the 
/// plugins are defined.
///
/// The @b filter plugin must provide a callback to allocate the 
/// @b Filter object (the one that is derived from comms_champion::Filter).
/// @code
/// class MyFilterPlugin : public comms_champion::Plugin
/// {
///     Q_OBJECT
///     Q_PLUGIN_METADATA(IID "MyUniqueFilterId" FILE "my_filter.json")
///     Q_INTERFACES(comms_champion::Plugin)
///
/// public:
///     MyFilterPlugin()
///     {
///         pluginProperties()
///             .setFiltersCreateFunc(
///                 [this]() -> comms_champion::PluginProperties::ListOfFilters
///                 {
///                     comms_champion::PluginProperties::ListOfFilters filters;
///                     filters.append(comms_champion::FilterPtr(new MyFilter));
///                     return filters;
///                 });
///     }
///             
///     ...
/// };
/// @endcode
/// If the @b filter requires configuration, please also provide a callback which
/// creates the widget when invoked (see @ref page_plugin_properties_config_widget).

