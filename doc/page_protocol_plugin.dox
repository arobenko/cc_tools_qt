/// @page page_protocol_plugin Developing Custom Protocol Plugin
/// @tableofcontents
/// Developing the @b protocol plugins is significantly more complex than
/// developing the @b socket or @b filter ones. Please follow this tutorial, 
/// while observing the implementation of the 
/// <a href="https://github.com/arobenko/comms_champion#demo-protocol">Demo Protocol</a>
/// (the sources are 
/// <a href="https://github.com/arobenko/comms_champion/tree/master/demo">here</a>) 
/// provided as part of the
/// <a href="https://github.com/arobenko/comms_champion">CommsChampion Project</a>.
///
/// @section page_protocol_plugin_protocol_def Protocol Definition
/// The protocol messages as well as wrapping transport information need to be
/// implemented using 
/// <a href="https://github.com/arobenko/comms_champion#comms-library">COMMS Library</a>.
/// in a certain generic way, which will allow it to be compiled and used
/// in any application, whether it is bare-metal platform with limited resouces or
/// @b protocol plugin for
/// <a href="https://github.com/arobenko/comms_champion#commschampion-tools">CommsChampion Tools</a>.
///
/// First of all, the common message interface class needs to inherit from or
/// be alias to @b comms::Message class, while providing only endian and type
/// of ID information as options. It must also provide variadic template 
/// parameter to allow extension of the interface with more options.
/// @code
/// namespace demo
/// {
/// 
/// template <typename... TOptions>
/// using Message =
///     comms::Message<
///         comms::option::BigEndian,
///         comms::option::MsgIdType<MsgId>, // MsgId is enum with numeric message IDs
///         TOptions...
///     >;
///
/// } // namespace demo
/// @endcode
/// Such definition leaves room for the application to define the required polymorphic
/// interface as well as choose iterators for read/write operations.
///
/// All the actual message definition classes are expected to receive their
/// interface class as a template parameter.
/// @code
/// namespace demo
/// {
///
/// template <typename TMsgBase>
/// class IntValues : public
///     comms::MessageBase<
///         TMsgBase,
///         comms::option::StaticNumIdImpl<MsgId_IntValues>,
///         comms::option::FieldsImpl<typename IntValuesFields<typename TMsgBase::Field>::All>,
///         comms::option::MsgType<IntValues<TMsgBase> >
///     >
/// {
///     ...
/// };
///
/// } // namespace demo
/// @endcode
/// @b NOTE, that the message definition class inherits from @b comms::MessageBase,
/// which will inherit from provided @b TMsgBase template parameter. The
/// provided template parameter must be alias to, or ihererit (directly or indirectly) from
/// @b comms::Message.
///
/// When defining transport layers, allow selection of the common interface
/// class as well as input messages as template parameters (see
/// <a href="https://github.com/arobenko/comms_champion/blob/master/demo/include/demo/Stack.h">Stack.h</a>
/// as an example).
/// @code
/// namespace demo
/// {
///
/// template <typename TMsgBase, typename TMessages, ...>
/// using Stack = ...;
///
/// } // namespace demo
/// @endcode 
///
/// @section page_protocol_plugin_message Messages in Plugin Environment
/// When developing plugin for <b>CommsChampion Tools</b>, there is a need
/// to define separate message interface class, which inherits from
/// comms_champion::MessageBase and provides the defined earlier interface
/// class as its template parameter. See 
/// <a href="https://github.com/arobenko/comms_champion/blob/master/demo/cc_plugin/Message.h">cc_plugin/Message.h</a> as an example.
/// @code
/// namespace demo
/// {
/// 
/// namespace cc_plugin
/// {
/// 
/// class Message : public comms_champion::MessageBase<demo::Message>
/// {
///     ...
/// };
/// 
/// }  // namespace cc_plugin
/// 
/// }  // namespace demo
/// @endcode
/// Please note, that the first template
/// parameter of comms_champion::MessageBase is a "template template" 
/// one, and the common interface class name defined earlier (@b demo::Message)
/// is passed to it "as-is" without angle brackets.
///
/// The comms_champion::MessageBase uses multiple inheritance to extend both
/// comms_champion::Message and provided custom protocol message interface class
/// (@b demo::Message). When extending provided interface class,
/// additional options are passed to it to allow full available polymorphic interface 
/// (read, write, length retrieval, validity check, etc...). The comms_champion::Message
/// is the main interface class used by the <b>CommsChampion Tools</b> 
/// to manipulate messages. 
///
/// The class hierarchy will look like this:
/// @diafile plugin_heirarchy.dia
///
/// The comms_champion::Message interface class has multiple pure virtual
/// functions, many of them are implemented inside comms_champion::MessageBase.
/// One of them is comms_champion::Message::idAsStringImpl(). It is used to
/// convert the message numeric ID into string representation to display it 
/// to user. The default implementation inside comms_champion::MessageBase will
/// convert it as is. However, it is recommended to override this function and
/// provide better formatting.
/// @code
/// namespace demo
/// {
/// 
/// namespace cc_plugin
/// {
/// 
/// class Message : public comms_champion::MessageBase<demo::Message>
/// {
/// protected:
///     virtual QString idAsStringImpl() const override
///     {
///         // uses getId() inherited from demo::Message
///         return QString("0x%1").arg(getId(), 2, 16, QChar('0'));
///     }
/// };
/// 
/// }  // namespace cc_plugin
/// 
/// }  // namespace demo
/// @endcode
/// 
/// Please note, that there are two polymorphic interface classes: 
/// comms_champion::Message and @b comms::Message (or @b demo::Message). The
/// latter defines its virtual functions, which are implemented as part of
/// protocol message definition (using @b comms::MessageBase). 
/// The comms_champion::Message is used only by
/// <b>CommsChampion Tools</b> and defines its own (pure) virtual functions 
/// which are expected to be overridden by the message implementation class.
/// One of them is message name retrieval.
/// @code
/// namespace comms_champion
/// {
///
/// class Message
/// {
///     ...
/// protected:
///     virtual const char* nameImpl() const = 0;
/// };
///
/// } // namespace comms_champion
/// @endcode
///
/// In order to be able to instantiate message object this pure virtual function
/// needs to be implemented. In order to do this, there is a need to extend
/// the existing implementation of the defined protocol message and implement
/// missing function. Let's take
/// <a href="https://github.com/arobenko/comms_champion/blob/master/demo/include/demo/message/IntValues.h">IntValues.h</a> and
/// <a href="https://github.com/arobenko/comms_champion/blob/master/demo/cc_plugin/message/IntValues.h">cc_plugin/message/IntValues.h</a> 
/// as an example. The latter is implemented in the following way:
/// @code
/// namespace demo
/// {
/// namespace cc_plugin
/// {
/// namespace message
/// {
///
/// class IntValues : public 
///     comms_champion::ProtocolMessageBase<
///         demo::message::IntValues<demo::cc_plugin::Message>,
///         IntValues
///     >
/// {
///     ...
/// protected:
///     virtual const char* nameImpl() const override
///     {
///         return "IntValues";
///     }
/// };
/// } // namespace message
/// } // namespace cc_plugin
/// } // namespace demo
/// @endcode
/// Please note that the class inherits from comms_champion::ProtocolMessageBase,
/// which overrides and implements two pure virtual functions defined by
/// comms_champion::Message: 
/// @li comms_champion::Message::assignImpl()
/// @li comms_champion::Message::resetImpl()
/// 
/// Also note, that comms_champion::ProtocolMessageBase class receives two
/// template parameters. The first one is the protocol message class the 
/// comms_champion::ProtocolMessageBase will inherit from 
/// (@b demo::message::IntValues<demo::cc_plugin::Message>). 
/// The second one is the type of the message class itself (@b IntValues).
///
/// One more thing to note, is the previously defined @b demo::cc_plugin::Message
/// is passed as interface class to @b demo::message::IntValues (as a 
/// template parameter).
///
/// The full inheritence hierarchy will look like this:
/// @diafile plugin_full_heirarchy.dia
///
/// @section page_protocol_plugin_fields_properties Fields and Their Properties
/// The <b>CommsChampion Tools</b> are there to help visualise and debug custom
/// binary protocols. The definition of the messages using @b COMMS library 
/// is used to define serialisation and deserialisation of the protocol messages.
/// However, such definitions do not cantain any extra information on how the message fields
/// need to be displayed. For example, when displaying a value of 
/// @b comms::field::EnumValue field, there is a need to display a human 
/// readable "name" of the value in addition to its serialised raw bytes.
///
/// <img src="image/enum_value_field.png">
///
/// In order to provide the required information, the message definition class
/// for the protocol plugin (@b demo::cc_plugin::IntValues) is expected to override inherited 
/// comms_champion::Message::fieldsPropertiesImpl() and provide the required
/// properties of the fields.
/// @code
/// namespace demo
/// {
/// namespace cc_plugin
/// {
/// namespace message
/// {
///
/// class IntValues : public 
///     comms_champion::ProtocolMessageBase<
///         demo::message::IntValues<demo::cc_plugin::Message>,
///         IntValues
///     >
/// {
///     ...
/// protected:
///     virtual const QVariantList& fieldsPropertiesImpl() const override
///     {
///         static const QVariantList Props = createFieldsProperties(); // defined in anonymous namespace
///         return Props;
///     }
/// };
/// } // namespace message
/// } // namespace cc_plugin
/// } // namespace demo
/// @endcode
/// @b NOTE, that the properties are defined as `const static` variable
/// and created only once upon first entry. The field's properties are the
/// description on the way how the fields need to be displayed and do not
/// depend on the field's value.
/// 
/// Also note, that the properties are stored in QVariantList, size of which
/// must be equal to number of fields, the message contains.
/// @code
/// namespace
/// {
/// QVariantList createFieldsProperties()
/// {
///     QVariantList props;
///     props.append(.../* properties of field1 */);
///     props.append(.../* properties of field2 */);
///     ...
/// 
///     assert(props.size() == IntValues::FieldIdx_numOfValues);
///     return props;
/// }
/// } // namespace
/// @endcode
///
/// One more thing to note is that set of properties for a single field are stored in
/// @b QVariantMap. However, it is implicitly converted to @b QVariant when inserted
/// into the @b QVariantList.
///
/// The helper classes that allow definition of the fields' properties reside
/// in comms_champion::property::field namespace, please refer to
/// @ref page_fields_properties separate tutorial page for details on how to
/// use them.

