/// @page page_protocol_plugin Developing Custom Protocol Plugin
/// @tableofcontents
/// Developing the @b protocol plugins is significantly more complex than
/// developing the @b socket or @b filter ones. Please follow this tutorial, 
/// while observing the implementation of the 
/// <a href="https://github.com/arobenko/comms_champion#demo-protocol">Demo Protocol</a>
/// (the sources are 
/// <a href="https://github.com/arobenko/comms_champion/tree/master/demo">here</a>) 
/// provided as part of the
/// <a href="https://github.com/arobenko/comms_champion">CommsChampion Project</a>.
///
/// @section page_protocol_plugin_protocol_def Protocol Definition
/// The protocol messages as well as wrapping transport information need to be
/// implemented using 
/// <a href="https://github.com/arobenko/comms_champion#comms-library">COMMS Library</a>.
/// in a certain generic way, which will allow it to be compiled and used
/// in any application, whether it is bare-metal platform with limited resouces or
/// @b protocol plugin for
/// <a href="https://github.com/arobenko/comms_champion#commschampion-tools">CommsChampion Tools</a>.
///
/// First of all, the common message interface class needs to inherit from or
/// be alias to @b comms::Message class, while providing only endian and type
/// of ID information as options. It must also provide variadic template 
/// parameter to allow extension of the interface with more options.
/// @code
/// namespace demo
/// {
/// 
/// template <typename... TOptions>
/// using Message =
///     comms::Message<
///         comms::option::BigEndian,
///         comms::option::MsgIdType<MsgId>, // MsgId is enum with numeric message IDs
///         TOptions...
///     >;
///
/// } // namespace demo
/// @endcode
/// Such definition leaves room for the application to define the required polymorphic
/// interface as well as choose iterators for read/write operations.
///
/// All the actual message definition classes are expected to receive their
/// interface class as a template parameter.
/// @code
/// namespace demo
/// {
///
/// template <typename TMsgBase>
/// class IntValues : public
///     comms::MessageBase<
///         TMsgBase,
///         comms::option::StaticNumIdImpl<MsgId_IntValues>,
///         comms::option::FieldsImpl<typename IntValuesFields<typename TMsgBase::Field>::All>,
///         comms::option::MsgType<IntValues<TMsgBase> >
///     >
/// {
///     ...
/// };
///
/// } // namespace demo
/// @endcode
/// @b NOTE, that the message definition class inherits from @b comms::MessageBase,
/// which will inherit from provided @b TMsgBase template parameter. The
/// provided template parameter must be alias to, or ihererit (directly or indirectly) from
/// @b comms::Message.
///
/// When defining transport layers, allow selection of the common interface
/// class as well as input messages as template parameters (see
/// <a href="https://github.com/arobenko/comms_champion/blob/master/demo/include/demo/Stack.h">Stack.h</a>
/// as an example).
/// @code
/// namespace demo
/// {
///
/// template <typename TMsgBase, typename TMessages, ...>
/// using Stack = ...;
///
/// } // namespace demo
/// @endcode 
///
/// @section page_protocol_plugin_message Messages in Plugin Environment
/// when developing plugin for <b>CommsChampion Tools</b> there is a need
/// to define separate message interface class, which inherits from
/// comms_champion::MessageBase and provides the defined earlier interface
/// class as its template parameter. See 
/// <a href="https://github.com/arobenko/comms_champion/blob/master/demo/cc_plugin/Message.h">cc_plugin/Message.h</a> as an example.
/// @code
/// namespace demo
/// {
/// 
/// namespace cc_plugin
/// {
/// 
/// class Message : public comms_champion::MessageBase<demo::Message>
/// {
///     ...
/// };
/// 
/// }  // namespace cc_plugin
/// 
/// }  // namespace demo
/// @endcode
/// The comms_champion::MessageBase in turn inherits from comms_champion::Message
/// as well as provided interface class. The comms_champion::Message
/// is the main interface class used by the <b>CommsChampion Tools</b> 
/// to manipulate messages. Please note, that the first template
/// parameter of comms_champion::MessageBase is a "template template" 
/// one, and the common interface class name defined earlier (@b demo::Message)
/// is passed to it "as-is" without angle brackets.
///
/// The class hierarchy will look like this:
/// @diafile plugin_heirarchy.dia
///
/// The comms_champion::Message interface class has multiple pure virtual
/// functions, many of them is implemented inside comms_champion::MessageBase.
/// One of them is comms_champion::Message::idAsStringImpl(). It is used to
/// convert the message numeric ID into string representation to display it 
/// to user. The default implementation inside comms_champion::MessageBase will
/// convert it as is. However, it is recommended to override this function and
/// provide better formatting.
/// @code
/// namespace demo
/// {
/// 
/// namespace cc_plugin
/// {
/// 
/// class Message : public comms_champion::MessageBase<demo::Message>
/// {
/// protected:
///     virtual QString idAsStringImpl() const override
///     {
///         // uses getId() inherited from demo::Message
///         return QString("0x%1").arg(getId(), 2, 16, QChar('0'));
///     }
/// };
/// 
/// }  // namespace cc_plugin
/// 
/// }  // namespace demo
/// @endcode
/// 
