/// @page page_filter_plugin Developing Custom Filter Plugin
/// @tableofcontents
/// The @b filter plugin is responsible to perform intermediate processing of
/// incoming data after it has been received by the I/O @b socket and prior to it
/// it being delivered to the @b protocol. It is also responsible to perform
/// intermediate processing of outgoing data generated by the @b protocol and 
/// prior to it being delivered to I/O @b socket for sending.
/// 
/// The @b filters can be used to implement additional transport layer, such
/// as <a href="http://mqtt.org">MQTT</a>.
/// They can also be used to implement encryption / decryption of the outgoing /
/// incoming data.
///
/// @section page_filter_plugin_filter_class Filter Class
/// To implement the required functionality the plugin's code must define its
/// filter class inheriting from @ref cc_tools_qt::ToolsFilter.
/// @code
/// class MyFilter : public cc_tools_qt::ToolsFilter
/// {
///     ...
/// };
/// @endcode
/// The @ref cc_tools_qt::ToolsFilter class is implemented using
/// <a href="https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Non-Virtual_Interface">Non-Virtual Interface Idiom</a>.
/// Its non-virtual public interface is used by the driving application. The
/// inheriting class needs to implement virtual @b *Impl() functions to override
/// the default behaviour.
///
/// @subsection page_filter_plugin_start_stop Start / Stop
/// The @b filter object is not allowed to generate any events prior to being
/// explicitly @b started. It is also not allowed to generate any events after
/// it has been explicitly @b stopped. The driving application will use explicit
/// calls to @ref cc_tools_qt::ToolsFilter::start() and @ref cc_tools_qt::ToolsFilter::stop()
/// to control the operation of the filter. In order to receive the notifications
/// on the start / stop operations, the actual filter class needs to override
/// virtual @ref cc_tools_qt::ToolsFilter::startImpl() "startImpl()" and
/// @ref cc_tools_qt::ToolsFilter::stopImpl() "stopImpl()" member functions.
/// @code
/// class MyFilter : public cc_tools_qt::ToolsFilter
/// {
///     ...
/// protected:
///     virtual bool startImpl() override;
///     virtual void stopImpl() override;
/// };
/// @endcode
///
/// @subsection page_filter_plugin_socket_connect Socket Connection Status
/// The communication link is driven by the @ref page_socket_plugin "socket" plugin.
/// Quite often it can be necessary for the filter plugin to be aware about socket
/// connection status. To do so override the virtual
/// @ref cc_tools_qt::ToolsFilter::socketConnectionReportImpl() "socketConnectionReportImpl()"
/// member function
/// @code
/// class MyFilter : public cc_tools_qt::ToolsFilter
/// {
///     ...
/// protected:
///     virtual void socketConnectionReportImpl(bool connected) override;
/// };
/// @endcode
///
/// @subsection page_filter_plugin_data_proc Processing Data
/// The new incoming data will be reported to the @b filter using virtual
/// @ref cc_tools_qt::ToolsFilter::recvDataImpl() "recvDataImpl()" member function. The derived class must override and
/// implement it.
/// @code
/// class MyFilter : public cc_tools_qt::ToolsFilter
/// {
///     ...
/// protected:
///     virtual QList<cc_tools_qt::ToolsDataInfoPtr> recvDataImpl(cc_tools_qt::ToolsDataInfoPtr dataPtr) override;
/// };
/// @endcode
/// @b NOTE, that the return value from the function is a list of smart pointers
/// to the @ref cc_tools_qt::ToolsDataInfo. Every such "data chunk" will be forwarded
/// separately to the @b protocol or other @b filter up the chain.
///
/// The @b filter is allowed to consume the provided data and not to report
/// anything for further processing. In this case the returned list will be empty.
///
/// The outgoing data generated by the @b protocol and/or other filter will be
/// reported using virtual @ref cc_tools_qt::ToolsFilter::sendDataImpl() "sendDataImpl()"
/// member function. The derived class must override and implement it.
/// @code
/// class MyFilter : public cc_tools_qt::ToolsFilter
/// {
///     ...
/// protected:
///     virtual QList<cc_tools_qt::ToolsDataInfoPtr> sendDataImpl(cc_tools_qt::ToolsDataInfoPtr dataPtr) override;
/// };
/// @endcode
/// It is very similar to @b recvDataImpl() mentioned above
///
/// @subsection page_filter_plugin_data_gen Generating Data
/// The @b filter class is allowed to generate outgoing data independently. It
/// could be required when implementing "additional transport layer" filtering.
/// If such data needs to be set, the @b filter class should use inherited
/// @ref cc_tools_qt::ToolsFilter::reportDataToSend() "reportDataToSend()" protected member function.
///
/// @subsection page_filter_plugin_errors Reporting Errors
/// If there is any error discovered, the @b filter object is expected to report 
/// them using inherited @ref cc_tools_qt::ToolsFilter::reportError() "reportError()" member function.
///
/// @section page_filter_plugin_plugin_class Plugin Class
/// Please read the @ref page_plugin page first to understand the way the 
/// plugins are defined.
///
/// The @b filter plugin must specify its type as @ref cc_tools_qt::ToolsPlugin::Type_Filter "Type_Filter" and override
/// @ref cc_tools_qt::ToolsPlugin::createFilterImpl() "createFilterImpl()" virtual member function.
/// @code
/// class MyFilterPlugin : public cc_tools_qt::ToolsPlugin
/// {
///     Q_OBJECT
///     Q_PLUGIN_METADATA(IID "MyUniqueFilterId" FILE "my_filter.json")
///     Q_INTERFACES(cc_tools_qt::ToolsPlugin)
///
///     using Base = cc_tools_qt::ToolsPlugin;
///
/// public:
///     MyFilterPlugin() : Base(Type_Filter) {}
///             
/// protected:
///     virtual cc_tools_qt::ToolsFilterPtr createFilterImpl() override {...}
///     ...
/// };
/// @endcode
/// If the @b filter requires configuration, please also provide a callback which
/// creates the widget when invoked (see @ref page_plugin_config_widget).

